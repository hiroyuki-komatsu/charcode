<html>
  <head>
    <style>
.char {
  display: inline-block;
  border: 1px solid lightgrey;
  width: 80px;
  height: 130px;
  vertical-align: top;
  margin: 2px;
  margin-top: 10px;
  padding: 3px;
  padding-top: 10px;
  position: relative;
}

.char input {
  font-size: 16px;
  width: 100%;
}

.char .delete {
  position: absolute;
  right: -7px;
  top: -7px;
  cursor: pointer;
  color: #fff;
  border: 1px solid #AEAEAE;
  border-radius: 10px;
  width: 20px;
  height: 20px;
  background: #605F61;
  font-size: 20px;
  text-align: center;
  line-height: 19px;
  font-weight: bold;
}

.plus {
  display: inline-block;
  font-size: 46px;
  width: 50px;
  height: 80px;
  vertical-align: middle;
  margin: 0px;
  padding: 20px;
  padding-top: 50px;
}

.utf8 {
  font-size: 10px;
}

.utf16 {
  font-size: 10px;
}

.link {
  font-size: 10px;
}

.text {
  font-size: 30px;
}
    </style>
  </head>
  <body>
    <div id="main"></div>
    <script>
function getHex(number, size=4) {
  let hex = number.toString(16).toUpperCase();
  if (hex.length >= size) {
    return hex;
  }

  return ("0000" + hex).substr(hex.length, size);
}

class Chars {
  constructor(id, value, onUpdate) {
    this.id = id;
    this.chars = Chars.parse(value);
    this.onUpdate = onUpdate;
  }

  setValue(value) {
    this.chars = Chars.parse(value);
    this.onUpdate();
  }

  getValue() {
    return this.chars.join("");
  }

  getLength() {
    return this.chars.length;
  }

  getCharAt(i) {
    return this.chars[i];
  }

  getCodePointAt(i) {
    return this.chars[i].codePointAt(0);
  }

  static parse(value) {
    return Encoder.getUtf32Array(value).map(x => String.fromCodePoint(x));
  }

  replace(index, char) {
    this.chars.splice(index, 1, char);
    this.setValue(this.getValue());
    this.onUpdate();
  }

  insert(index, char) {
    this.chars.splice(index, 0, char);
    this.onUpdate();
  }

  delete(index) {
    this.chars.splice(index, 1);
    this.onUpdate();
  }
}

class Encoder {
  static getEncodings() {
    return ["utf32-amp", "utf32-u", "utf16-u", "utf8-x", "utf8-pct"];
  }

  static getDefaultEncoding() {
    return "utf32-amp";
  }

  static getLabel(encoding, fallback="") {
    const dict = {
      "utf32-amp": "UTF32 &#xNNNN;",
      "utf32-u": "UTF32 \\u{NNNN}",
      "utf16-u": "UTF16 \\uNNNN",
      "utf8-x": "UTF8 \\xNN",
      "utf8-pct": "UTF8 %NN",
    };
    return dict[encoding] || fallback;
  }

  static encode(value, encoding) {
    let encoded = "";
    switch(encoding) {
      case "utf32-amp":
        encoded = this.encodeUtf32(value, "&#x", ";");
        break;
        case "utf32-u":
        encoded = this.encodeUtf32(value, "\\u{", "}");
        break;
      case "utf16-u":
        encoded = this.encodeUtf16(value, "\\u", "");
        break;
      case "utf8-x":
        encoded = this.encodeUtf8(value, "\\x", "");
        break;
      case "utf8-pct":
        encoded = this.encodeUtf8(value, "%", "");
        break;
      default:
        encoded = "invalid encoding";
    }
    return encoded;
  }

  static getUtf8Array(str) {
    let utf8s = [];
    const utf8encoded = encodeURIComponent(str);
    for (let i = 0; i < utf8encoded.length; ++i) {
      if (utf8encoded[i] != "%") {
        utf8s.push(utf8encoded[i].charCodeAt(0));
      } else {
        utf8s.push(parseInt(utf8encoded.slice(i + 1, i + 3), 16));
        i += 2;
      }
    }
    return utf8s;
  }

  static getUtf16Array(str) {
    let utf16s = [];
    for (let i = 0; i < str.length; ++i) {
      utf16s.push(str.charCodeAt(i));
    }
    return utf16s;
  }

  static getUtf32Array(str) {
    let utf32s = [];
    for (let i = 0; i < str.length; ++i) {
      const codePoint = str.codePointAt(i);
      const charCode = str.charCodeAt(i);
      // If codePoint is more than 0xFFFF, charCode is a part of surrogate pair.
      if (codePoint !== charCode) {
        i++;
      }
      utf32s.push(codePoint);
    }
    return utf32s;
  }

  static encodeUtf(str, getUtfArrayFunc, size, prefix="", suffix="", delimiter="") {
    const utfs = getUtfArrayFunc(str);
    const encoded = utfs.map(x => { return prefix + getHex(x, size) + suffix; });
    return encoded.join(delimiter);
  }

  static encodeUtf8(str, prefix="", suffix="", delimiter="") {
    return this.encodeUtf(str, this.getUtf8Array, 2, prefix, suffix, delimiter);
  }

  static encodeUtf16(str, prefix="", suffix="", delimiter="") {
    return this.encodeUtf(str, this.getUtf16Array, 4, prefix, suffix, delimiter);
  }

  static encodeUtf32(str, prefix="", suffix="", delimiter="") {
    return this.encodeUtf(str, this.getUtf32Array, 4, prefix, suffix, delimiter);
  }
}

class EncodeElement {
  constructor(encode, callback) {
    this.element = document.createElement("div");
    this.element.innerHTML = (
      `<select class="encode"></select>` +
      `<span class="encoded"></span>`
    );
    this.selectElement = this.element.getElementsByClassName("encode")[0];
    let optionsHtml = "";
    for (let encoding of Encoder.getEncodings()) {
      optionsHtml += `<option value="${encoding}">${Encoder.getLabel(encoding)}</option>`;
    }
    this.selectElement.innerHTML = optionsHtml;
    this.selectElement.value = encode;
    this.selectElement.addEventListener("change", (event) => {
      callback(event);
    });
  }

  getEncode() {
    return this.selectElement.value;
  }

  draw(value) {
    let encodedElement = this.element.getElementsByClassName("encoded")[0];
    encodedElement.innerText = value;
  }
}

class SessionManager {
  constructor() {
    this.nextId = 0;
    this.data = {};
  }

  newChars(value, onUpdate) {
    let chars = new Chars(this.nextId, value, onUpdate);
    this.data[this.nextId] = chars;
    this.nextId++;
    return chars;
  }

  getDndProtocol(chars, index) {
    return [chars.id, index].join("\t");
  }

  moveChar(srcProtocol, dstProtocol) {
    const src = srcProtocol.split("\t");
    const srcId = parseInt(src[0]);
    const srcIndex = parseInt(src[1]);
    const dst = dstProtocol.split("\t");
    const dstId = parseInt(dst[0]);
    const dstIndex = parseInt(dst[1]);

    const char = this.data[srcId].getCharAt(srcIndex);
    this.data[srcId].delete(srcIndex);
    this.data[dstId].insert(dstIndex, char);
  }
}

class Viewer {
  constructor(sessionManager, value, encoding) {
    this.sessionManager = sessionManager;
    this.chars = sessionManager.newChars(value, () => {this.draw()});

    this.base = document.createElement("div");
    this.base.innerHTML = (
      `<input type="text" class="text"></input>` +
      `<div class="output"></div>` +
      `<div class="encode"></div>` +
      `<hr />`);

    this.input = this.base.getElementsByClassName("text")[0];
    this.output = this.base.getElementsByClassName("output")[0];
    this.encode = new EncodeElement(encoding, (event) => {this.draw();});
    this.base.getElementsByClassName("encode")[0].appendChild(this.encode.element);

    this.input.addEventListener("input", (event) => {
      this.chars.setValue(this.input.value);
    });
    this.draw();
  }

  draw() {
    const value = this.chars.getValue();
    this.input.value = value;
    this.output.innerHTML = "";

    for (let i = 0; i < this.chars.getLength(); ++i) {
      this.output.appendChild(this.createCharElement(i));
    }
    this.output.appendChild(this.createPlusElement(value.length));
    this.encode.draw(Encoder.encode(value, this.encode.getEncode()));
    setUrl(value, this.encode.getEncode());
  }

  onDrag(event, index) {
    const protocol = this.sessionManager.getDndProtocol(this.chars, index);
    event.dataTransfer.setData("text/plain", protocol);
  }

  onDrop(event, index) {
    const srcProtocol = event.dataTransfer.getData("text/plain");
    const dstProtocol = this.sessionManager.getDndProtocol(this.chars, index);
    this.sessionManager.moveChar(srcProtocol, dstProtocol);
  }

  createCharElement(index) {
    let charElement = document.createElement("div");
    charElement.className = "char";
    charElement.draggable = true;
    const codePoint = this.chars.getCodePointAt(index);
    const utf8String = Encoder.encodeUtf8(this.chars.getCharAt(index), "", "", " ");
    const utf16String = Encoder.encodeUtf16(this.chars.getCharAt(index), "", "", " ");
    const codePointHex = getHex(codePoint);

    const codePointChar = this.chars.getCharAt(index);
    const url = `http://unicode.org/cldr/utility/character.jsp?a=${codePointHex}`;
    charElement.innerHTML = (
      `<div class="delete">✖</div>` +
      `<div><input class="codePointHex" type="text" value="${codePointHex}" /></div>` +
      `<div><input class="codePointChar" type="text" value="${codePointChar}" /></div>` +
      `<div class="utf8">${utf8String}</div>` +
      `<div class="utf16">${utf16String}</div>` +
      `<div class="link"><a href="${url}">properties</a></div>`);
    let codePointHexElement = charElement.getElementsByClassName("codePointHex")[0];
    codePointHexElement.addEventListener("change", () => {
      this.chars.replace(index, String.fromCodePoint(parseInt(codePointHexElement.value, 16)));
    });

    let codePointCharElement = charElement.getElementsByClassName("codePointChar")[0];
    codePointCharElement.addEventListener("change", () => {
      this.chars.replace(index, codePointCharElement.value);
    });

    let deleteElement = charElement.getElementsByClassName("delete")[0];
    deleteElement.style.display = "none";
    deleteElement.addEventListener("click", () => {
      this.chars.delete(index);
    })

    // Delete button on mouse over
    charElement.addEventListener("mouseover", () => {
      deleteElement.style.display = "";
    });
    charElement.addEventListener("mouseleave", () => {
      deleteElement.style.display = "none";
    });

    // Drag and Drop
    charElement.addEventListener("dragstart", () => {
      deleteElement.style.display = "none";
      this.onDrag(event, index);
    });

    charElement.addEventListener("dragover", () => {
      event.preventDefault();
    });

    charElement.addEventListener("drop", () => {
      event.preventDefault();
      this.onDrop(event, index);
    });

    return charElement;
  }

  createPlusElement(index) {
    let plus = document.createElement("div");
    plus.className = "plus";
    plus.innerText = "⊕";
    plus.addEventListener("click", () => {
      this.chars.insert(index, " ");
    });
    return plus;
  }
}

function addViewer(viewer) {
  document.getElementById("main").appendChild(viewer.base);
}

function setUrl(text, encode) {
  const params = `text=${encodeURIComponent(text)}&encode=${encodeURIComponent(encode)}`;
  history.replaceState("", "", location.pathname + "?" + params);
}

const params = new URLSearchParams(window.location.search);
const text = params.get("text") || "(๑•̀ㅂ•́)و✧";
const encoding = params.get("encode") || Encoder.getDefaultEncoding();

let sessionManager = new SessionManager();

let viewer = new Viewer(sessionManager, text, encoding);
addViewer(viewer);

let addButton = document.createElement("input");
addButton.type = "button";
addButton.value = "Add";
addButton.addEventListener("click", (event) => {
  addViewer(new Viewer(sessionManager, "(๑•̀ㅂ•́)و✧", encoding));
});
document.body.appendChild(addButton);
    </script>
  </body>
</html>
